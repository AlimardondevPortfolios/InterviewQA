# InterviewQA
Interview questions and answers

# Python
# 1-question and answer
## Python nima?

[//]: # (````shell)
#answer
Python nima?
Python — bu yuqori darajadagi, umumiy maqsadli va interpretatsiyalanadigan dasturlash tili bo'lib, Guido van Rossum tomonidan 1980-yillarda ishlab chiqilgan va 1991-yilda birinchi marta chiqarilgan. Pythonning asosiy maqsadi — o'qilishi oson, sintaksisi sodda, va dasturchilarga tez va samarali dastur yozish imkonini beruvchi til yaratish edi.
-------------------------------------------------------------
Pythonning asosiy xususiyatlari:
1. Yuqori darajali dasturlash tili: Python'da dasturlash uchun tizim xotirasi va resurslarini boshqarish haqida qayg'urmaslik kerak. U avtomatik xotira boshqarish va "garbage collection" kabi vositalarni o'zi boshqaradi.

2.  Interpretatsiyalanadigan: Python kodlari oldindan kompilyatsiya qilinmasdan, bevosita "Python interpretatori" tomonidan o'qiladi va bajariladi. Bu, kodni tez sinovdan o'tkazish va osonlik bilan o'zgartirish imkonini beradi.

3. O'qilishi oson va minimal sintaksis: Pythonning asosiy ustunliklaridan biri uning sintaksisining soddaligi. Bu yangi dasturchilar uchun o'rganishni ancha yengillashtiradi.

4. Kross-platformali: Python ko'p operatsion tizimlarda, masalan, Windows, macOS, Linux kabi tizimlarda ishlashi mumkin. Dastur bitta tizimda ishlab chiqilgandan keyin boshqa tizimlarda o'zgartirishsiz ishlashi mumkin.

5. Interaktiv muhit: Python o'zining interaktiv interpretatori bilan birga keladi, bu orqali dasturchilar kodni yozib uni darhol sinab ko'rishlari mumkin. Bu, ayniqsa, sinovlar va tezkor prototiplash uchun qulay.

6. Kengaytirilgan kutubxonalar to'plami: Python keng kutubxonalar to'plamiga ega. Kutubxonalar yordamida har xil vazifalar, masalan, web dasturlash, ma'lumotlar tahlili, mashinaviy o'rganish, sun'iy intellekt, va boshqa ko'plab vazifalarni bajarish osonlashadi.

7. Obyektga yo'naltirilgan dasturlash (OOP): Python obyektga yo'naltirilgan dasturlash modelini qo'llab-quvvatlaydi. Bu dasturlash paradigmasi yordamida kodni yanada tuzilmali va qayta foydalanishga mos holatda yaratish mumkin.
--------------------------------------------------------------------------
Python tarixiga qisqacha nazar
Python dastlab 1980-yillarda ishlab chiqilgan va dastlabki rasmiy chiqarilishi 1991-yilda amalga oshirilgan. Pythonning nomi, ko'pchilik o'ylaganidek, ilonlar nomidan kelib chiqmagan. Uning nomi inglizlarning mashhur "Monty Python’s Flying Circus" ko'ngilochar komediya dasturidan ilhomlangan.

* Python 2.0: 2000-yilda Python 2.0 versiyasi chiqarildi va u tilni kengroq auditoriyaga yetkazishda muhim rol o'ynadi. Ammo Python 2.0 o'zgarishlari keyinchalik Python 3.0 bilan mos kelmasligi sabab bo'ldi.

* Python 3.0: 2008-yilda chiqarilgan Python 3.0'dan asosiy maqsad eski tilni optimallashtirish va yangi imkoniyatlar qo'shish edi. Python 3.0'dan boshlab tilga ko'plab muhim o'zgartirishlar kiritildi. Python 2'ning rivojlantirilishi 2020-yilda to'xtatildi va hozirgi kunda Python 3 standart hisoblanadi.

--------------------------------------------------------
Pythonning afzalliklari
1. O'rganishga oson: Python'ning sodda sintaksisi uni yangi boshlovchilar uchun o'rganishni osonlashtiradi. Bu boshqa dasturlash tillariga qaraganda ko'proq soddalashtirilgan va tabiiy tilda yozilganga o'xshaydi.

2. Ochiq manba va bepul: Python ochiq manbali dasturlash tili bo'lib, har kim uni bepul yuklab olishi va ishlatishi mumkin. Shuningdek, Pythonning rivojlanishi dunyo miqyosidagi ochiq manbali jamoa tomonidan qo'llab-quvvatlanadi.

3. Keng ko'lamdagi dasturlarni ishlab chiqish imkoniyati: Python yordamida veb-dasturlar, ma'lumotlar tahlili, ilmiy hisob-kitoblar, o'yinlar, sun'iy intellekt va mashinaviy o'rganish kabi turli sohalarda dasturlar yozish mumkin.

4. Keng kutubxonalari: Python kutubxonalarining katta ekotizimiga ega. Bu kutubxonalar turli sohalar uchun zarur bo'lgan asbob-uskunalar bilan ta'minlaydi (masalan, NumPy, Pandas, TensorFlow, Django va boshqalar).

5. Ko'p paradigmatik yondashuv: Python obyektga yo'naltirilgan, protsedural va funksional dasturlash paradigmalari bilan ishlash imkoniyatiga ega.
------------------------------------------------------------------------------
Pythonning kamchiliklari
1. Sekin bajarilish tezligi: Python boshqa kompilyatsiyalanadigan tillarga (masalan, C yoki C++) nisbatan sekin ishlaydi, chunki Python interpretatsiyalanadigan til hisoblanadi.

2. Mobil ilovalar uchun mos emas: Python asosan web va serverda ishlatiladigan dasturlar uchun mo'ljallangan. Mobil ilovalar yaratishda Python kamroq qo'llaniladi.

3. Ko'p oqimlik dasturlar uchun cheklangan imkoniyat: Python'da "Global Interpreter Lock" (GIL) mavjudligi sababli ko'p oqimli dasturlar samaradorligini pasaytirishi mumkin.

--------------------------------------------------------------------------
Python qaysi sohalarda qo'llaniladi?
1. Python ko'p funksiyali va turli sohalarda keng qo'llaniladigan dasturlash tili hisoblanadi:

2. Web dasturlash: Django, Flask kabi web framework'lar yordamida Python web dasturlar yaratish uchun keng qo'llaniladi.

3. Ma'lumotlar tahlili va ilmiy hisob-kitoblar: NumPy, Pandas, Matplotlib kabi kutubxonalar orqali ma'lumotlarni tahlil qilish va ilmiy hisoblashlarni amalga oshirish mumkin.

4. Sun'iy intellekt va mashinaviy o'rganish: TensorFlow, Keras, Scikit-learn kabi kutubxonalar yordamida Python sun'iy intellekt va mashinaviy o'rganish algoritmlarini yaratishda qo'llaniladi.

5. O'yin dasturlash: Pygame kabi kutubxona yordamida Python'da sodda o'yinlarni yaratish mumkin.

6. Avtomatlashtirish va skriptlash: Python ko'pincha tizimlarni avtomatlashtirish va skriptlar yozish uchun ishlatiladi.

7. Testlash: Python dasturlarni avtomatlashtirilgan testdan o'tkazish va dasturiy ta'minotni sinovdan o'tkazish uchun juda mosdir (masalan, UnitTest, PyTest).

----------------------------------------------------------------------
Xulosa
Python — bu oddiy, o'rganishga oson, kengaytirilgan kutubxonalarga ega va ko'p sohalarda foydalanish mumkin bo'lgan dasturlash tili. Yuqori samaradorlik, keng qo'llanish imkoniyatlari va dasturlash paradigmasiga moslashuvchanligi tufayli Python bugungi kunda dunyodagi eng ommabop dasturlash tillaridan biri hisoblanadi.

[//]: # (````)

# 2-question and answer
## Dasturlash tillari qanday tiplarga bo'linadi?
Dasturlash tillari asosan ikki turga bo'linadi:

1. Statik tipdagi tillar: Bu tillarda o'zgaruvchi turlari dastur bajarilishidan oldin aniqlanadi va kompilyatsiya vaqtida tekshiriladi. Masalan, C, C++, Java.

2. Dinamik tipdagi tillar: Bu tillarda o'zgaruvchi turlari dastur bajarilishi vaqtida aniqlanadi. Masalan, Python, JavaScript.

* Kompilyator tillari: Bu tillarda kod dastlab kompilyatsiya qilinadi, ya'ni mashina tiliga tarjima qilinib, keyin bajariladi. Masalan, C, C++.

* Interpretor tillari: Bu tillarda kod qadam-baqadam interpretor tomonidan bevosita bajariladi, ya'ni tarjima qilish vaqti yo'q. Masalan, Python, Ruby

# 3-question and answer
## Pythonda qanday data typelar bor
Python'da quyidagi asosiy data tiplari mavjud:

1. int (Butun sonlar)
2. float (Haqiqiy sonlar)
3. complex (Kompleks sonlar)
4. str (Matnlar)
5. list (Ro'yxatlar)
6. tuple (O'zgarmas ro'yxatlar)
7. range (x = range(6))
8. dict (Lug'atlar)
9. set (To'plamlar)
10. frozenset (O'zgarmas to'plamlar)
11. bool (Mantiqiy qiymatlar)
12. bytes (Baytlar)
13. bytearray (Baytlar massivlari)
14. memoryview (Xotira ko'rinishlari)
15. NoneType (Hech qanday qiymatni anglatmaydi) 

# 4-question and answer
## Tuple va Setni qanday farqi bor?
Tuple va Set o'rtasidagi asosiy farqlar quyidagicha:

1. Tartiblanganligi:

* Tuple: Elementlari tartiblangan (indexed), ya'ni har bir elementning aniq o'rni (indeksi) bor. Elementlarga indeks orqali murojaat qilish mumkin.
* Set: Tartiblanmagan, elementlar qaysi tartibda kiritilgan bo'lsa ham o'z-o'zidan o'rin almashadi. Indeks yoki tartib mavjud emas.
2. Takrorlanuvchi elementlar:
* Tuple: Ichida bir xil elementlar bir necha marta bo'lishi mumkin.
* Set: Takrorlanuvchi elementlarga yo'l qo'ymaydi, har bir element unikal bo'lishi kerak.
3. O'zgartirilishi:
* Tuple: O'zgarmas (immutable), ya'ni yaratib bo'lgandan keyin uning elementlarini o'zgartirish mumkin emas.
* Set: O'zgaruvchan (mutable), ya'ni elementlar qo'shish, o'chirish mumkin.
4. Qulaylik:
* Tuple: Tartiblangan ma'lumotlar to'plamini saqlash uchun qulay.
* Set: Takrorlanmaydigan elementlarni saqlash va elementlarni tez-tez qidirish uchun ishlatiladi.
Misol:
```shell
# Tuple misoli
my_tuple = (1, 2, 3, 2)  # Takrorlanadigan va tartiblangan

# Set misoli
my_set = {1, 2, 3, 2}  # Takrorlanuvchi elementlarni qabul qilmaydi

# Natijada, my_setda faqat {1, 2, 3} qoladi.
```

# 5-question and answer
## SET va Frozensetni qanday farqlari bor?
Set va Frozenset o'rtasidagi asosiy farqlar:

1. O'zgartirilishi:
* Set: O'zgaruvchan (mutable), ya'ni elementlarni qo'shish, o'chirish, o'zgartirish mumkin.
* Frozenset: O'zgarmas (immutable), ya'ni yaratilgandan keyin elementlarni o'zgartirish yoki o'chirish mumkin emas.
2. Qo'llanilishi:
* Set: O'zgaruvchan to'plamlar bilan ishlash talab qilinganda ishlatiladi, masalan, elementlarni qo'shish va olib tashlash kerak bo'lsa.
* Frozenset: O'zgarmas va xotira samarador bo'lishi kerak bo'lganda, ayniqsa "kalit" sifatida ishlatilishi mumkin, masalan, lug'atlarda (dictionary) kalit sifatida.
3. Metodlar:
* Set: Metodlari bor, masalan, add(), remove(), discard(), clear() kabi metodlar orqali elementlarni o'zgartirish mumkin.
* Frozenset: Bu metodlar mavjud emas, faqat o'zgarmaydigan operatsiyalarni bajarish mumkin (union(), intersection() kabi).
4. Xotirada saqlanishi:
* Set: O'zgaruvchan bo'lgani uchun set xotirada ko'proq joy olishi mumkin, chunki o'zgarishlar uchun qo'shimcha joy kerak bo'ladi.
* Frozenset: O'zgarmas bo'lgani uchun xotirada samarali ishlaydi, chunki qo'shimcha o'zgarishlar uchun joy kerak emas.
5. Kalit sifatida ishlatish:
* Set: Lug'at (dictionary) va boshqa setlarda kalit sifatida ishlatilishi mumkin emas, chunki o'zgaruvchan.
* Frozenset: Lug'atda kalit sifatida yoki setlar ichida element sifatida ishlatilishi mumkin, chunki u o'zgarmaydi.

Misol:
```shell
my_set = {1, 2, 3}
my_frozenset = frozenset([1, 2, 3])
```

# 6-question and answer
## Pythonda bytelar haqida gapiring?
Python'da bytes - o'zgarmas (immutable) ma'lumot turi bo'lib, u xom baytlar ketma-ketligini (0 va 255 orasidagi sonlar) ifodalaydi. Asosan, ma'lumotlarni tarmoqlar orqali uzatish yoki fayllarni kodlashda qo'llaniladi.

Asosiy xususiyatlari:

* O'zgarmas: bytes bir marta yaratilgandan keyin o'zgartirib bo'lmaydi.
* 0-255 qiymatlar: Har bir element 0 va 255 orasidagi qiymat bo'ladi.
* Matnli va ikkilik ma'lumotlar bilan ishlaydi: Kodlash va dekodlash jarayonlarida ishlatiladi.
* Yaratish: bytes() funksiyasi yoki baytli string prefiksi b'' orqali yaratiladi.
Misol:
```shell
# bytes yaratish
my_bytes = b'Hello'
print(my_bytes)  # Natija: b'Hello'

# bytes yaratish int qiymatlardan
my_bytes_from_ints = bytes([72, 101, 108, 108, 111])
print(my_bytes_from_ints)  # Natija: b'Hello'
```

# 7-question and answer
## Baytearray va memoryview haqida nimalarni bilasiz?
bytearray va memoryview Python'da ikkilik ma'lumotlar bilan ishlash uchun maxsus ma'lumot turlari hisoblanadi. Ularning har biri o'ziga xos xususiyatlarga ega.

### bytearray:
* O'zgaruvchan (mutable) tur bo'lib, bytes ma'lumot turiga o'xshaydi, lekin o'zgartirish mumkin.
* Ikkilik ma'lumotlar bilan ishlaganda, elementlarni qo'shish, o'chirish yoki o'zgartirish imkoni bor.
* bytearray ichida 0 va 255 orasidagi butun sonlar (baytlar) saqlanadi.
### Asosiy xususiyatlar:
* Mutable: Yaratilgandan keyin elementlarini o'zgartirish mumkin.
* Qo'llanilishi: Fayl va tarmoqlardan ikkilik ma'lumotlarni o'zgartirishga ehtiyoj bo'lganda ishlatiladi.
Misol:
```shell
ba = bytearray(b"Hello")
ba[0] = 104  # 'H' ni kichik 'h' ga o'zgartiradi
print(ba)  # Natija: bytearray(b'hello')
```
#### memoryview:
* O'zgarmas (immutable) tur bo'lib, mavjud ikkilik obyektlarga (masalan, bytes yoki bytearray) yuqori darajadagi interfeys beradi, ularni xotirada o'zgartirmasdan ko'rish va tahlil qilish imkonini beradi.
* Bu xotira samaradorligini oshirish uchun ishlatiladi, chunki katta obyektlarni nusxa ko'chirmasdan turib ularga murojaat qilish mumkin.
### Asosiy xususiyatlar:
* Tezkor xotira ulanishi: Ma'lumotlarni yangi nusxa yaratmasdan to'g'ridan-to'g'ri xotiradan o'qish yoki tahlil qilish mumkin.
* Qo'llanilishi: Katta hajmli ma'lumotlar (masalan, video yoki katta fayllar) bilan ishlaganda xotira iste'molini kamaytirish uchun ishlatiladi.
Misol:
```shell
data = bytearray(b"Hello")
mv = memoryview(data)
print(mv[0])  # Natija: 72 (ASCII kod qiymati)
```
Xulosa:
1. bytearray - o'zgaruvchan baytlar ketma-ketligini yaratish va o'zgartirish uchun ishlatiladi.
2. memoryview - ma'lumotlarni xotira nuqtai nazaridan samarali ishlatish uchun, nusxa ko'chirmasdan to'g'ridan-to'g'ri ko'rish imkonini beradi.


# 8-question and answer
## Pythonda memory management haqida nima bilasiz?
Python'da memory management (xotira boshqaruvi) avtomatik ravishda amalga oshiriladi va xotirani boshqarish uchun bir nechta mexanizmlar mavjud. Eng asosiylari:

1. Garbage Collection (Axlat to'plovchi):
* Python o'lik obyektlarni avtomatik aniqlab, ulardan xotirani tozalash uchun garbage collector (axlat yig'uvchi) mexanizmini ishlatadi.
* Python'da har bir obyektning reference count (havola soni) saqlanadi. Agar obyektga havolalar soni 0 ga tushsa, u xotiradan o'chiriladi.
* Circular reference (a va b bir-biriga ishora qilganda) masalalarida, Python'da qo'shimcha cycle detector mavjud bo'lib, bunday obyektlarni aniqlab, tozalaydi.

2. Reference Counting (Havola sonini kuzatish):
* Har bir obyektni necha joyda ishlatilayotganini kuzatib boradi.
* Obyektga boshqa o'zgaruvchi yoki obyekt havola qilinganida uning reference count ortadi. Havola olib tashlanganda yoki obyekt foydalanishdan chiqqanda bu son kamayadi.
* Agar obyektga havolalar soni 0 bo'lsa, xotira avtomatik ravishda bo'shatiladi.
3. Heap Memory (Xotira maydoni):
* Python obyektlari va ma'lumotlar heap deb ataladigan katta xotira hududida saqlanadi. Bu xotira avtomatik ravishda boshqariladi.
* Python'da memory allocator (xotira ajratuvchi) heap xotirani boshqaradi, yangi obyektlar uchun joy ajratadi yoki bo'shatadi.
4. PyObject Allocator (Obyektlar uchun maxsus ajratgich):
* Python PyObject deb ataluvchi barcha obyektlarni yaratadi. PyObject allocator orqali obyektlar xotiraga joylashtiriladi va ularning hajmini nazorat qiladi.
* Bu allocator tez-tez ishlatiladigan kichik obyektlar uchun samarali ishlashi uchun optimallashtirilgan.
5. Memory Pooling:
* Tez-tez yaratiladigan va o'chiriladigan kichik obyektlar uchun Python memory pooling texnikasini ishlatadi. Bu yangi obyektlarni yaratishda xotira almashish jarayonini samarali qilishga yordam beradi.
* Masalan, kichik obyektlar (masalan, int, float kabi) uchun Python ma'lum xotira maydonini ajratib qo'yadi va yangi obyektlar uchun o'sha ajratilgan joydan foydalanadi.

### Xulosa:
Python'da xotira boshqaruvi avtomatik tarzda amalga oshiriladi va bu jarayonni samarali qilish uchun garbage collection, reference counting, va memory pooling kabi mexanizmlar ishlatiladi.

# 9-question and answer
## Decorator va class decorator nima?
Decorator:
1. Decorator — funksiyaga yoki metoda qo'shimcha funksionallik qo'shish uchun ishlatiladigan konstruktsiya.
2.  Ular asl funksiyani o'zgartirmasdan, uning xatti-harakatlarini kengaytiradi.
3. Python'da @ belgisi bilan yoziladi va funksiyadan oldin qo'llaniladi.
Misol:
```shell
def decorator(func):
    def wrapper():
        print("Qo'shimcha kod")
        func()  # Asl funksiya
    return wrapper

@decorator
def hello():
    print("Hello!")

hello()
# natija:
#Qo'shimcha kod
#Hello!
```

## Class Decorator:
1. Class decorator — sinf darajasidagi dekorator bo'lib, u sinfni o'rab, unga qo'shimcha funksionallik qo'shadi.
2. Dekorator funksiyasi sinfni argument sifatida oladi va qaytishda o'zgartirilgan yoki yangilangan sinfni qaytaradi.
Misol:
```shell
def class_decorator(cls):
    class Wrapped(cls):
        def new_method(self):
            print("Yangi metod")
    return Wrapped

@class_decorator
class MyClass:
    def original_method(self):
        print("Asl metod")

obj = MyClass()
obj.original_method()
obj.new_method()
# natija:
#Asl metod
#Yangi metod
```
## Xulosa:
1. Decorator: Funksiyaga yoki metoda qo'shimcha xatti-harakat qo'shadi.
2. Class Decorator: Sinfga yangi xususiyatlar qo'shish yoki mavjudini kengaytirish uchun ishlatiladi.

# 10-question and answer
## OOP nima?
OOP (Object-Oriented Programming) — ob'ektga yo'naltirilgan dasturlash paradigmasi bo'lib, dasturiy ta'minotni yaratish va boshqarish usulidir. OOP dasturlash tillari ob'ektlar, sinflar, va ular o'rtasidagi munosabatlar asosida ishlaydi.
OOP dasturlash paradigmasi dasturiy ta'minotni ob'ektlar va sinflar yordamida tuzadi va boshqaradi. Bu metodlar va ma'lumotlarni bir joyda saqlash, kodni qayta ishlatish, va dasturiy tizimni samarali boshqarish imkonini beradi.
## Avzalliklari:
1. Kodning qayta ishlatilishi:
Sinflar va obyektlar yordamida mavjud kodni boshqa joylarda foydalanish mumkin. Meros olish (inheritance) va polymorphism (polimorfizm) orqali mavjud kodlarni qayta ishlatish imkoniyatlari mavjud.
2. Modularlik:
Kodni kichik va mustaqil bo'limlarga ajratish orqali dasturiy ta'minotni boshqarishni osonlashtiradi. Har bir sinf va ob'ekt o'zining ma'lumotlari va funksiyalariga ega bo'ladi.
3. Kodni soddalashtirish:
Abstraktsiya va inkapsulatsiya yordamida murakkab tizimlarni soddalashtirish va tushunishni osonlashtiradi. Ma'lumotlar va metodlar bir ob'ektda birlashtiriladi.
4. Oson kengaytirilishi:
Dasturiy ta'minotni yangi xususiyatlar yoki ob'ektlar qo'shish orqali kengaytirish osonroq. Yangi sinflar yaratish va mavjud sinflarni kengaytirish mumkin.
5. Xatolarni kamaytirish:
Inkapsulatsiya orqali ma'lumotlarni himoya qilish va metodlar yordamida ma'lumotlarga boshqaruvni ta'minlash orqali xatolarni kamaytirish mumkin.

## Kamchiliklari:
1. Murakkablik:
OOP paradigmalarini to'g'ri tushunish va qo'llash o'rganish talab qilinadi, bu dasturchilar uchun murakkablik yaratishi mumkin. Katta va murakkab tizimlarda sinf va ob'ektlar o'rtasidagi munosabatlar qiyinlashtirilishi mumkin.
2. Resurslarni sarflash:
OOP dasturlashda ko'proq xotira va protsessor resurslari talab qilinishi mumkin, chunki obyektlar va sinflar yaratish va boshqarish jarayonida qo'shimcha resurslar sarflanadi.
3. Xotira hajmi:
Sinf va ob'ektlar tuzilmalari dastur kodining hajmini oshirishi mumkin. Bu, ayniqsa, kichik va oddiy dasturlar uchun ortiqcha yukni yaratishi mumkin.
4. Murakkablikni oshirish:
OOP kodni ob'ektlar va sinflar orqali tashkil etish murakkablikni oshirishi mumkin. Har bir sinf va ob'ektning o'ziga xos xususiyatlari va metodlarini tushunish talab etiladi.
5. Performans muammolari:
OOP tizimlari ba'zan samaradorlikni pasaytirishi mumkin, ayniqsa ob'ektlar va sinflar o'rtasidagi ko'p darajali meros olish va polimorfizm ishlatilganida.


## Xulosa:
OOP dasturlash paradigmasi kodning qayta ishlatilishini, modularligini va soddalashtirilishini ta'minlaydi, ammo ba'zi hollarda murakkablik, resurs sarfi va samaradorlik bilan bog'liq kamchiliklarga olib kelishi mumkin.

# -------------------------------------------------------------------
# Django
# 11 - question and answer
## Django nima va nega ishlatiladi?
Django — yuqori darajadagi Python web framework bo'lib, tez rivojlanishni va to'liq xususiyatli veb-ilovalarni yaratishni qo'llab-quvvatlaydi. Django o'z ichiga ma'lumotlar bazasi, foydalanuvchi autentifikatsiyasi, admin paneli va boshqa ko'plab qurilmalarga ega. Uning asosiy xususiyatlari quyidagilardan iborat:

* MVC/MVT arxitekturasi: Model-View-Template (MVT) arxitekturasi orqali ma'lumotlar, ko'rinishlar va shablonlar ajratiladi.
* Tez rivojlanish: Django tez rivojlanishni qo'llab-quvvatlaydi va ishlab chiqish jarayonini soddalashtiradi.
* Qurilgan xususiyatlar: Django o'z ichiga kirish, xavfsizlik, va boshqaruv uchun ko'plab qurilgan xususiyatlarga ega.

# 12 -  question and answer
## Django'dagi Model-View-Controller (MVC) va Model-View-Template (MVT) o'rtasidagi farq nima?
Django Model-View-Template (MVT) arxitekturasidan foydalanadi, bu esa MVC (Model-View-Controller) dan farq qiladi:

Model: Ma'lumotlar bazasi tuzilishini belgilaydi va ma'lumotlarni saqlaydi.
View: Ma'lumotlarni taqdim etadi va foydalanuvchi so'rovlariga javob beradi. Django'da views.py faylida joylashgan.
Template: HTML shablonlarni yaratadi, bu orqali ma'lumotlarni foydalanuvchiga ko'rsatadi. Django'da templates papkasi orqali boshqariladi.
MVC modelida esa:

Controller: Ko'rinishlarni (views) ma'lumotlar bilan bog'laydi. Django'da bu vazifani views amalga oshiradi.

# 13-question and answer
## Django modeli nima?
Django modeli — ma'lumotlar bazasi tuzilishini belgilaydigan sinfdir. Modelda har bir sinf bir ma'lumotlar bazasi jadvalini ifodalaydi. Modellar models.py faylida yaratiladi va quyidagilarni o'z ichiga oladi:

* Fieldlar: Ma'lumotlar bazasi ustunlarini ifodalaydi (masalan, CharField, IntegerField).
* Metodlar: Ma'lumotlar bilan bog'liq xatti-harakatlarni amalga oshiradi.
# 14-question and answer
## Django qanday qilib ma'lumotlar bazasini migratsiya qiladi?
Django ma'lumotlar bazasini migratsiya qilish uchun quyidagi buyruqlardan foydalanadi:

* makemigrations: Modifikatsiyalarni aniqlaydi va migratsiya fayllarini yaratadi.
* migrate: Yaratilgan migratsiya fayllarini ma'lumotlar bazasiga qo'llaydi va bazaning joriy holatini yangilaydi.

# 15-question and answer
## Django'da QuerySet nima?
QuerySet — Django ORM orqali ma'lumotlarni olish, filtrlash va manipulyatsiya qilish uchun ishlatiladigan obyektlar to'plamidir. QuerySetlar QuerySet sinfi orqali yaratiladi va ularni quyidagi tarzda ishlatish mumkin:

* Ma'lumotlarni olish: Model.objects.all() kabi metodlar orqali.
* Filtrlash: Model.objects.filter(field=value) kabi metodlar yordamida.
* Manipulyatsiya qilish: update(), delete() va boshqa metodlar orqali.

# 16-question and answer
## Django'dagi GET va POST metodlari o'rtasidagi farq nima?
* GET: Ma'lumotlarni serverdan olish uchun ishlatiladi. URL orqali parametrlar uzatiladi va ma'lumotlar ko'rinishi uchun ishlatiladi. GET so'rovlar odatda ma'lumotlarni ko'rish uchun qo'llaniladi.
* POST: Serverga yangi ma'lumotlarni yuborish yoki mavjud ma'lumotlarni yangilash uchun ishlatiladi. POST so'rovlar ko'pincha forma orqali ma'lumotlarni yuborish uchun qo'llaniladi va ko'proq xavfsizdir, chunki ma'lumotlar tanasida yuboriladi.

# 17-question and answer
## Django middleware nima?
Middleware — Django ilovasida so'rovlar va javoblarni qamrab oladigan va ular bilan ishlov beradigan komponentdir. Middleware quyidagi vazifalarni bajarishi mumkin:

* So'rovlarni modifikatsiya qilish: So'rovlar kelib tushganda ularni tahlil qilish yoki modifikatsiya qilish.
* Javoblarni modifikatsiya qilish: Javoblar qaytarilganida ularni tahrirlash yoki ularga qo'shimchalar kiritish.
* Xavfsizlik: Xavfsizlik tekshiruvlarini amalga oshirish, masalan, CSRF himoyasi.
Middleware MIDDLEWARE sozlamalari orqali Django loyihasida ro'yxatga olinadi va middleware papkasi yoki faylida joylashadi.

# 18-question and answer
## Django ORM nima va qanday ishlaydi?
Django ORM (Object-Relational Mapping) — bu ma'lumotlar bazasi bilan ishlashni soddalashtiruvchi tizim bo'lib, ma'lumotlar bazasidagi jadvallarni Python sinflari bilan bog'laydi. ORM orqali siz Python kodidan ma'lumotlar bazasi so'rovlarini amalga oshirishingiz mumkin, bu esa SQL yozishni osonlashtiradi. Django ORM quyidagilarni o'z ichiga oladi:

* Model: Ma'lumotlar bazasi jadvallarini ifodalaydi. Model sinfi models.Model dan meros oladi.
* QuerySet: Ma'lumotlarni olish, filtrlash va manipulyatsiya qilish uchun ishlatiladi. Misol uchun, Model.objects.all() barcha yozuvlarni olish uchun ishlatiladi.
* Migrations: Modeldagi o'zgarishlarni ma'lumotlar bazasiga qo'llash uchun ishlatiladi.


# 19-question and answer
## Django'da qanday qilib maxsus manager yaratish mumkin?
Maxsus managerlar Django modellari uchun qo'shimcha yoki o'zgartirilgan QuerySet funksiyalarini yaratishga imkon beradi. Maxsus manager yaratish uchun:

1. Manager sinfini yaratish: models.Manager sinfidan meros olish va kerakli metodlarni qo'shish.
2. Modelga manager qo'shish: Modelda yaratilgan manager sinfini atribut sifatida belgilash.
Misol:
```shell
from django.db import models

class CustomManager(models.Manager):
    def active(self):
        return self.filter(is_active=True)

class MyModel(models.Model):
    is_active = models.BooleanField(default=True)
    objects = CustomManager()

```
Bu kod MyModel uchun active metodini qo'shadi, bu metod faqat is_active=True bo'lgan yozuvlarni qaytaradi.

# 20-question and answer
## Django Form nima va qanday ishlaydi?
Django forma — foydalanuvchi kiritgan ma'lumotlarni olish va tekshirish uchun ishlatiladigan vositadir. Django formasi quyidagi funksiyalarni bajaradi:

* Forma yaratish: forms.Form yoki forms.ModelForm sinflaridan foydalanib forma sinfini yaratish.
* Tekshirish: Forma yuborilganda, ma'lumotlarning to'g'riligi va to'liqligini tekshiradi.
* Shablonlarda ko'rsatish: Formalarni HTML shaklida ko'rsatadi va foydalanuvchi kiritgan ma'lumotlarni qabul qiladi.
Misol:
```shell
from django import forms

class ContactForm(forms.Form):
    name = forms.CharField(max_length=100)
    email = forms.EmailField()
    message = forms.CharField(widget=forms.Textarea)

    def clean_message(self):
        message = self.cleaned_data.get('message')
        if 'spam' in message:
            raise forms.ValidationError("No spam allowed!")
        return message
```
# 21-question and answer
## Django'da foydalanuvchi autentifikatsiyasini qanday amalga oshirasiz?
Django o'z ichki autentifikatsiya tizimini taqdim etadi. Foydalanuvchi autentifikatsiyasi uchun:

* Login: django.contrib.auth moduli orqali login() funksiyasi yordamida foydalanuvchini tizimga kiritish.
* Logout: logout() funksiyasi yordamida foydalanuvchini tizimdan chiqarish.
* Registratsiya: Yangi foydalanuvchilarni ro'yxatdan o'tkazish uchun foydalanuvchi formalarini yaratish va saqlash.
Misol:
```shell
from django.contrib.auth import login, logout
from django.contrib.auth.forms import UserCreationForm
from django.shortcuts import render, redirect

def register(request):
    if request.method == 'POST':
        form = UserCreationForm(request.POST)
        if form.is_valid():
            form.save()
            return redirect('login')
    else:
        form = UserCreationForm()
    return render(request, 'register.html', {'form': form})

```
# 22-question and answer
## Django qanday qilib statik fayllarni boshqaradi?
Django statik fayllarni (CSS, JavaScript, rasm) boshqarishni quyidagi tarzda amalga oshiradi:

* STATIC_URL: Statik fayllarni URL orqali taqdim etish uchun ishlatiladi. Masalan, STATIC_URL = '/static/'.
* STATICFILES_DIRS: Statik fayllarni saqlash joylarini ko'rsatadi.
* collectstatic: Statik fayllarni yig'ish va tarqatish uchun ishlatiladi.
Misol:
```shell
# settings.py
STATIC_URL = '/static/'
STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]

```
# 23-question and answe
## Django'da signals nima?
Signals — Django ilovasida ayrim voqealar yuz berganda (masalan, model saqlanganda) xabar yuborish uchun ishlatiladi. Signals yordamida kodni ajratish va voqealarga javob berish mumkin. Signals post_save, pre_save kabi signal turlaridan foydalanadi.

Misol:
```shell
from django.db.models.signals import post_save
from django.dispatch import receiver
from .models import MyModel

@receiver(post_save, sender=MyModel)
def my_model_saved(sender, instance, **kwargs):
    print(f"{instance} model saqlandi")
```
# 24-question and answer
## Django'ning urls.py fayli qanday ishlaydi?
urls.py fayli URL marshrutizatsiyasini boshqaradi. U URL'larni views funksiyalari yoki sinflariga moslashtiradi. URL konfigurasiyasi orqali foydalanuvchi so'rovlarini qaysi view tomonidan qayta ishlanishini belgilaydi.

Misol:
```shell
from django.urls import path
from . import views

urlpatterns = [
    path('', views.home, name='home'),
    path('about/', views.about, name='about'),
]

```
# 25-question and answer
## Django'ning sinfga asoslangan ko'rinishlari (CBV) va funksiyaga asoslangan ko'rinishlar (FBV) o'rtasidagi farq nima?
* Sinfga asoslangan ko'rinishlar (CBV): Django'da ko'rinishlarni sinflar yordamida yaratish va kengaytirish imkonini beradi. Bu metodlar va attributlar yordamida qayta foydalanish va kengaytirish oson.
* Funksiyaga asoslangan ko'rinishlar (FBV): Ko'rinishlarni oddiy funksiyalar yordamida yaratish va yozish imkonini beradi. Bu usul oddiyroq va ko'proq nazorat qilish imkoniyatini taqdim etadi.
Misol (CBV):
```shell
from django.views.generic import ListView
from .models import MyModel

class MyModelListView(ListView):
    model = MyModel
    template_name = 'my_model_list.html'
```
Misol (FBV):
```shell
from django.shortcuts import render
from .models import MyModel

def my_model_list(request):
    objects = MyModel.objects.all()
    return render(request, 'my_model_list.html', {'objects': objects})
```

# 26-question and answer
## Django'da ma'lumotlar bazasi so'rovlarini qanday optimallashtirasiz?
1. select_related(): Bu metod bir-to-bir yoki bir-ko'p munosabatlar bo'ylab so'rovlarni bir martada olish uchun ishlatiladi. Bu ma'lumotlarni olib kelishda qator so'rovlarni kamaytiradi, chunki bog'liq ob'ektlarni birgalikda yuklaydi.

Misol:
```shell
# User modelga bog'liq profile modelni olib kelish
users = User.objects.select_related('profile').all()

```
2. prefetch_related(): Bu metod ko'p-ko'p munosabatlar bo'ylab ma'lumotlarni olish uchun ishlatiladi. U bog'liq ob'ektlarni alohida so'rovlar orqali olishni amalga oshiradi va ma'lumotlarni "prefetch" qiladi.

Misol:
```shell
# User modelga bog'liq barcha postslarni olish
users = User.objects.prefetch_related('posts').all()

```
3. N+1 so'rov muammosidan qochish: Bu muammo bir asosiy so'rov bilan birga bog'liq ob'ektlar uchun ortiqcha so'rovlar yuborilishida yuzaga keladi. select_related() va prefetch_related() metodlarini ishlatish orqali bu muammoni oldini olish mumkin.

Misol (N+1 muammosi):
```shell
# Bu usul N+1 muammosini keltirib chiqaradi
for user in User.objects.all():
    print(user.profile.name)
```
Misol (optimizatsiya):
```shell
# select_related() orqali optimallashtirish
users = User.objects.select_related('profile').all()
for user in users:
    print(user.profile.name)
```

# 27-question and answer
## Django'ning session framework maqsadi nima?
Django'ning session frameworki foydalanuvchi sessiyalarini boshqarish uchun ishlatiladi. Sessiyalar foydalanuvchi ma'lumotlarini vaqtincha saqlash va server tomonida saqlash imkonini beradi. Django session frameworki quyidagilarni amalga oshiradi:

* Sessiya ma'lumotlarini saqlash: Sessiya ma'lumotlari serverda yoki cookie orqali saqlanadi.
* Sessiya middleware: Sessiya ma'lumotlarini so'rov va javoblarga qo'shadi va saqlaydi.
* Sessiya identifikatori: Har bir sessiya uchun noyob identifikator yaratiladi va bu identifikator cookie orqali foydalanuvchi tomonidan yuboriladi.
Misol:
```shell
# Sessiya ma'lumotlarini saqlash
def set_session(request):
    request.session['key'] = 'value'

# Sessiya ma'lumotlarini olish
def get_session(request):
    value = request.session.get('key', 'default')
```

# 28-question and answer
## Django'da fayl yuklashni qanday amalga oshirasiz?
Django'da fayl yuklashni FileField yoki ImageField yordamida amalga oshirishingiz mumkin. Media fayllarni sozlash uchun MEDIA_URL va MEDIA_ROOT parametrlarini sozlash kerak.

1. Model yaratish:
```shell
from django.db import models

class MyModel(models.Model):
    file = models.FileField(upload_to='files/')
    image = models.ImageField(upload_to='images/')
```
2. Media fayllarni sozlash:
```shell
# settings.py
MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

```
3. URL konfiguratsiyasi:
```shell
# urls.py
from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    # Boshqa URL'lar
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

```

# 29-question and answer
## Django'da REST nima va Django REST Framework (DRF) yordamida RESTful API qanday yaratish mumkin?
1. REST (Representational State Transfer) - HTTP metodlarini (GET, POST, PUT, DELETE) ishlatib ma'lumotlarni manipulyatsiya qilish va almashish usulidir. RESTful API'lar URL'lar orqali ma'lumotlarni olish va boshqarish imkonini beradi.

2. Django REST Framework (DRF): Django'ga RESTful API yaratish uchun kengaytmadir. DRF yordamida quyidagilarni amalga oshirishingiz mumkin:

* Serializers: Ma'lumotlarni JSON yoki boshqa formatlarga aylantirish.
* ViewSets: API so'rovlarini boshqarish uchun ko'rsatkichlar.
* Routers: URL'larni viewsetlarga moslashtirish.
Misol:
```shell
# serializers.py
from rest_framework import serializers
from .models import MyModel

class MyModelSerializer(serializers.ModelSerializer):
    class Meta:
        model = MyModel
        fields = '__all__'

# views.py
from rest_framework import viewsets
from .models import MyModel
from .serializers import MyModelSerializer

class MyModelViewSet(viewsets.ModelViewSet):
    queryset = MyModel.objects.all()
    serializer_class = MyModelSerializer

# urls.py
from rest_framework.routers import DefaultRouter
from .views import MyModelViewSet

router = DefaultRouter()
router.register(r'mymodel', MyModelViewSet)

urlpatterns = [
    # Boshqa URL'lar
] + router.urls

```

# 30-question and answer
## Django ilovalarida xavfsizlikni qanday ta'minlaysiz?
1. CSRF himoyasi: Django avtomatik ravishda Cross-Site Request Forgery (CSRF) hujumlariga qarshi himoya qiladi. @csrf_protect dekoratori yoki CsrfViewMiddleware middleware orqali qo'shimcha himoya qo'shish mumkin.

2. XSS oldini olish: Cross-Site Scripting (XSS) hujumlaridan himoya qilish uchun Django shablonlari avtomatik ravishda HTML kodlarini xavfsiz holatga keltiradi. Boshqa xavfsiz kod yozish amaliyotlariga amal qiling.

3. Xavfsizlik sozlamalari: Django xavfsizlikni yaxshilash uchun xavfsizlik sozlamalarini, masalan, SECURE_BROWSER_XSS_FILTER, SECURE_CONTENT_TYPE_NOSNIFF, va SECURE_SSL_REDIRECT parametrlarini sozlash kerak.

Misol:
```shell
# settings.py
CSRF_COOKIE_SECURE = True
SESSION_COOKIE_SECURE = True
X_FRAME_OPTIONS = 'DENY'
```

##  ---------------------------------------------------

